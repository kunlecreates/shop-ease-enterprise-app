name: Integration Tests — Staging

on:
  workflow_run:
    workflows: ["CD — Kubernetes Deploy (Helm)"]
    types: [completed]
  workflow_dispatch: {}

jobs:
  run-integration-tests:
    name: Run integration-tests against staging
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    env:
      ENV_FILE: integration-tests/env/ci.env
      E2E_BASE_URL: ${{ secrets.E2E_BASE_URL }}
      CF_ACCESS_CLIENT_ID: ${{ secrets.CF_ACCESS_CLIENT_ID }}
      CF_ACCESS_CLIENT_SECRET: ${{ secrets.CF_ACCESS_CLIENT_SECRET }}
      TEST_ADMIN_TOKEN: ${{ secrets.TEST_ADMIN_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        working-directory: integration-tests
        run: |
          if [ -f package-lock.json ]; then npm ci --include=dev; else npm install --include=dev; fi

      - name: Run integration tests
        working-directory: integration-tests
        env:
          ENV_FILE: integration-tests/env/ci.env
        run: |
          npm test -- --runInBand --reporters=default

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: integration-tests/test-results/**
name: Integration Tests
# Trigger update: touch to force CI re-run (autogenerated change)
# CI trigger: bump timestamp to rerun workflows - 2025-12-06T10:00:00Z

on:
  push:
    # Run on main/master and on CI topic branches used for testing.
    # Add the shared PR branch and a glob for test/* branches so pushes
    # to topics like `test/ci-*` will trigger the workflow.
    branches:
      - main
      - master
    # Only run this expensive integration matrix when cross-cutting, shared or infra
    # changes occur. Service-local changes are handled by per-service CI jobs.
    paths:
      - '.github/workflows/integration-tests.yml'
      - 'helm-charts/**'
  pull_request:
    branches: [ main, master ]
    paths:
      - '.github/workflows/**'
      - 'helm-charts/**'
  # Allow manual runs for diagnostics or ad-hoc verification
  workflow_dispatch: {}

# Ensure the workflow can read GitHub Packages if needed for package access
permissions:
  contents: read
  packages: read
jobs:

  service-tests:
    name: Run tests for services
    runs-on: ubuntu-latest
    env:
      DOCKER_API_VERSION: '1.52'
      # Ensure the GitHub token and actor are exported into the job environment so
      # helper scripts invoked via `bash` can read them reliably.
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GITHUB_ACTOR: ${{ github.actor }}
    strategy:
      matrix:
        service: [order-service, user-service, product-service, notification-service]
      # Allow running two service matrix jobs concurrently to reduce runtime
      # and the chance that a single service (the first in the list) appears
      # to always run for infra/global changes.
      max-parallel: 2
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure cache directories
        run: |
          mkdir -p "$HOME/.npm" "$HOME/.cache/pip"

      - name: Setup caches
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            ~/.cache/pip
          key: ${{ runner.os }}-build-${{ matrix.service }}-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ matrix.service }}-

      - name: Job-level environment setup
        run: |
          # Example: if the service requires local secrets or helper containers,
          # they can be started or environment variables exported here.
          # This block intentionally minimal; extend per-service as needed.
          case "${{ matrix.service }}" in
            order-service|user-service)
              echo "Java service: ensure Docker available for Testcontainers"
              docker --version || true
              ;;
            product-service)
              echo "Product service: enable Postgres Testcontainer for tests"
              echo "TEST_POSTGRES=1" >> $GITHUB_ENV
              ;;
            notification-service)
              echo "Notification service: may require SMTP test container in future"
              ;;
          esac

      - name: Write maven settings
        run: |
          bash ./scripts/write_maven_settings.sh "${{ github.actor }}" "${{ secrets.GITHUB_TOKEN }}"

      - name: Set up JDK 21 for Java services
        if: ${{ matrix.service == 'order-service' || matrix.service == 'user-service' }}
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'


      - name: Run tests for ${{ matrix.service }}
        run: |
          # Run tests using service-local test helpers and configurations
          set -e
          SERVICE_DIR="./services/${{ matrix.service }}"
          echo "Checking $SERVICE_DIR"
          if [ -f "$SERVICE_DIR/pom.xml" ]; then
            echo "Detected Maven service. Running mvn verify (includes integration tests)"
            mvn -B -s $HOME/.m2/settings.xml -U -f "$SERVICE_DIR" -Dapi.version=1.44 verify
          elif [ -f "$SERVICE_DIR/package.json" ]; then
            echo "Detected Node service. Installing and running npm test"
            pushd "$SERVICE_DIR"
            # Prefer npm ci when a lockfile exists, otherwise fall back to npm install
            if [ -f package-lock.json ] || [ -f npm-shrinkwrap.json ]; then
              npm ci
            else
              npm install
            fi
            npm test --silent || { echo 'npm test failed'; exit 1; }
            popd
          elif [ -f "$SERVICE_DIR/requirements.txt" ] || [ -f "$SERVICE_DIR/pyproject.toml" ]; then
            echo "Detected Python service. Running pytest from service dir"
            set -o pipefail
            # Run tests from inside the service directory so imports like `app` resolve
            pushd "$SERVICE_DIR"
            python3 -m pip install --upgrade pip || echo "pip upgrade failed"
            if [ -f requirements.txt ]; then
              python3 -m pip install -r requirements.txt || echo "pip install returned non-zero (continuing for debug)"
            fi
            # Ensure package imports resolve: include service dir on PYTHONPATH
            export PYTHONPATH="$(pwd)":$PYTHONPATH
            # Diagnostic removed: python sys.path printing was temporary
            # Run pytest with junit xml and capture logs; treat exit code 5 (no tests) as success
            rc=0
            pytest --maxfail=1 --junitxml=pytest-results.xml . > pytest.log 2>&1 || rc=$?
            if [ "$rc" -eq 5 ]; then
              echo "No tests collected for $SERVICE_DIR; continuing."
              rc=0
            fi
            if [ "$rc" -ne 0 ]; then
              echo "pytest failed with exit code $rc"
              cat pytest.log || true
              popd
              exit $rc
            fi
            popd
          else
            echo "No known test runner for $SERVICE_DIR; skipping"
          fi

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-artifacts
          path: |
            services/${{ matrix.service }}/pytest-results.xml
            services/${{ matrix.service }}/pytest.log
            services/${{ matrix.service }}/target/surefire-reports/**

