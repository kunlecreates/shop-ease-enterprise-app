name: Infra â€” Provision Secrets

on:
  workflow_dispatch:
    inputs:
      services:
        description: "Comma-separated services to provision (user,product,order,notification or 'all')"
        required: true
        default: "all"
  workflow_call:
    inputs:
      services:
        required: true
        type: string
    secrets:
      GHCR_READ_USERNAME:
        required: false
      GHCR_READ_TOKEN:
        required: false
      PRODUCT_DB_HOST:
        required: false
      PRODUCT_DB_PORT:
        required: false
      PRODUCT_DB_NAME:
        required: false
      PRODUCT_DB_USER:
        required: false
      PRODUCT_DB_PASSWORD:
        required: false
      PRODUCT_MIG_DB_USER:
        required: false
      PRODUCT_MIG_DB_PASSWORD:
        required: false
      USER_DB_HOST:
        required: false
      USER_DB_PORT:
        required: false
      USER_DB_NAME:
        required: false
      USER_DB_USER:
        required: false
      USER_DB_PASSWORD:
        required: false
      USER_MIG_DB_USER:
        required: false
      USER_MIG_DB_PASSWORD:
        required: false
      ORDER_DB_HOST:
        required: false
      ORDER_DB_PORT:
        required: false
      ORDER_DB_NAME:
        required: false
      ORDER_DB_USER:
        required: false
      ORDER_DB_PASSWORD:
        required: false
      ORDER_MIG_DB_USER:
        required: false
      ORDER_MIG_DB_PASSWORD:
        required: false
      NOTIFICATION_MAIL_HOST:
        required: false
      NOTIFICATION_MAIL_PORT:
        required: false
      NOTIFICATION_MAIL_USER:
        required: false
      NOTIFICATION_MAIL_PASSWORD:
        required: false
      NOTIFICATION_MAIL_FROM:
        required: false

jobs:
  provision:
    runs-on: arc-runnerset-instance
    env:
      OWNER: ${{ github.repository_owner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.15.3

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.30.0

      - name: Configure kubeconfig (ARC in-cluster)
        id: configure
        run: |
          set -euo pipefail
          if [ -z "${KUBERNETES_SERVICE_HOST:-}" ]; then
            echo "ERROR: This job requires running inside the cluster on an ARC runner (KUBERNETES_SERVICE_HOST not set)."
            exit 1
          fi
          APISERVER="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
          SA_TOKEN_FILE="/var/run/secrets/kubernetes.io/serviceaccount/token"
          CA_CERT_FILE="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
          KUBECONFIG_PATH="$PWD/kubeconfig"
          kubectl config set-cluster arc --server="$APISERVER" --certificate-authority="$CA_CERT_FILE" --embed-certs=true --kubeconfig="$KUBECONFIG_PATH"
          kubectl config set-credentials runner --token="$(cat "$SA_TOKEN_FILE")" --kubeconfig="$KUBECONFIG_PATH"
          kubectl config set-context arc --cluster=arc --user=runner --kubeconfig="$KUBECONFIG_PATH"
          kubectl config use-context arc --kubeconfig="$KUBECONFIG_PATH"
          echo "KUBECONFIG=$KUBECONFIG_PATH" >> $GITHUB_ENV
          echo "kubeconfig=$KUBECONFIG_PATH" >> $GITHUB_OUTPUT

      - name: Provision secrets (node)
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const env = process.env;

            function run(cmd, opts = {}) {
              console.log(`$ ${cmd}`);
              execSync(cmd, { stdio: 'inherit', env: process.env, shell: '/bin/bash', ...opts });
            }

            // Ensure RBAC namespace exists
            console.log('Ensuring shopease-system namespace exists');
            run('kubectl create namespace shopease-system --dry-run=client -o yaml | kubectl apply -f -');

            // Determine services list
            const input = env.INPUT_SERVICES || 'all';
            const all = ['product', 'user', 'order', 'notification', 'frontend'];
            let services = [];
            if (!input || input === 'all') {
              services = all;
            } else {
              services = input.split(',').map(s => s.trim()).filter(Boolean).map(s => {
                if (all.includes(s)) return s; console.log(`Ignoring unknown service '${s}'`); return null;
              }).filter(Boolean);
            }

            const namespaces = [];
            for (const svc of services) {
              switch (svc) {
                case 'product': namespaces.push('shopease-product'); break;
                case 'user': namespaces.push('shopease-user'); break;
                case 'order': namespaces.push('shopease-order'); break;
                case 'notification': namespaces.push('shopease-notification'); break;
                case 'frontend': namespaces.push('shopease-frontend'); break;
              }

              let NS = '';
              let SECRET_NAME = '';
              let dbKeys = [];
              let migKeys = [];
              let mailKeys = [];
              let PREFIX = '';

              switch (svc) {
                case 'frontend': NS = 'shopease-frontend'; break;
                case 'product':
                  NS = 'shopease-product'; SECRET_NAME = 'shopease-product-db';
                  dbKeys = ['PRODUCT_DB_HOST','PRODUCT_DB_PORT','PRODUCT_DB_NAME','PRODUCT_DB_USER','PRODUCT_DB_PASSWORD'];
                  migKeys = ['PRODUCT_MIG_DB_USER','PRODUCT_MIG_DB_PASSWORD','PRODUCT_MIG_DB_HOST','PRODUCT_MIG_DB_PORT','PRODUCT_MIG_DB_NAME'];
                  PREFIX = 'PRODUCT'; break;
                case 'user':
                  NS = 'shopease-user'; SECRET_NAME = 'shopease-user-db';
                  dbKeys = ['USER_DB_HOST','USER_DB_PORT','USER_DB_NAME','USER_DB_USER','USER_DB_PASSWORD'];
                  migKeys = ['USER_MIG_DB_USER','USER_MIG_DB_PASSWORD','USER_MIG_DB_HOST','USER_MIG_DB_PORT','USER_MIG_DB_NAME'];
                  PREFIX = 'USER'; break;
                case 'order':
                  NS = 'shopease-order'; SECRET_NAME = 'shopease-order-db';
                  dbKeys = ['ORDER_DB_HOST','ORDER_DB_PORT','ORDER_DB_NAME','ORDER_DB_USER','ORDER_DB_PASSWORD'];
                  migKeys = ['ORDER_MIG_DB_USER','ORDER_MIG_DB_PASSWORD','ORDER_MIG_DB_HOST','ORDER_MIG_DB_PORT','ORDER_MIG_DB_NAME'];
                  PREFIX = 'ORDER'; break;
                case 'notification':
                  NS = 'shopease-notification'; SECRET_NAME = 'shopease-notification-credentials';
                  mailKeys = ['NOTIFICATION_MAIL_HOST','NOTIFICATION_MAIL_PORT','NOTIFICATION_MAIL_USER','NOTIFICATION_MAIL_PASSWORD','NOTIFICATION_MAIL_FROM'];
                  break;
              }

              console.log(`Ensuring namespace ${NS} exists`);
              run(`kubectl create namespace ${NS} --dry-run=client -o yaml | kubectl apply -f -`);

              // Ensure imagePullSecret
              if (env.GHCR_READ_USERNAME && env.GHCR_READ_TOKEN) {
                run(`kubectl -n ${NS} create secret docker-registry ghcr-pull-secret --docker-server=ghcr.io --docker-username='${env.GHCR_READ_USERNAME}' --docker-password='${env.GHCR_READ_TOKEN}' --docker-email='noreply@github.com' --dry-run=client -o yaml | kubectl apply -f -`);
              } else {
                console.log('GHCR credentials not provided; skipping ghcr-pull-secret creation in', NS);
              }

              if (svc === 'notification') {
                const args = [];
                for (const k of mailKeys) {
                  const v = env[k]; if (v) args.push(`--from-literal=${k}=${v}`);
                }
                if (args.length) run(`kubectl -n ${NS} create secret generic ${SECRET_NAME} ${args.join(' ')} --dry-run=client -o yaml | kubectl apply -f -`);
              }

              if (svc !== 'frontend' && svc !== 'notification') {
                const args = [];
                for (const k of dbKeys) {
                  const v = env[k]; if (v) args.push(`--from-literal=${k}=${v}`);
                }
                if (args.length) run(`kubectl -n ${NS} create secret generic ${SECRET_NAME} ${args.join(' ')} --dry-run=client -o yaml | kubectl apply -f -`);
              }

              // migration secret
              if (PREFIX) {
                const migUser = env[`${PREFIX}_MIG_DB_USER`];
                const migPass = env[`${PREFIX}_MIG_DB_PASSWORD`];
                if (migUser && migPass) {
                  const args = [];
                  for (const k of migKeys) { const v = env[k]; if (v) args.push(`--from-literal=${k}=${v}`); }
                  if (args.length) run(`kubectl -n ${NS} create secret generic ${SECRET_NAME}-migration ${args.join(' ')} --dry-run=client -o yaml | kubectl apply -f -`);
                }
              }
            }

            // Build RBAC values and install chart
            const tmp = '/tmp/rbac-targets.yaml';
            const fs = require('fs');
            let out = 'targets:\n';
            for (const ns of namespaces) {
              out += `- namespace: ${ns}\n  serviceAccount: arc-runner-sa\n  subjectNamespace: arc-runners\n  roleName: deployer\n  bindingName: deployer-binding\n`;
            }
            fs.writeFileSync(tmp, out);
            console.log('Using temporary RBAC values file:', tmp);
            try { run('helm lint helm-charts/rbac || true'); } catch (e) {}
            run(`helm upgrade --install shopease-rbac helm-charts/rbac --namespace shopease-system --create-namespace --atomic --wait --timeout 5m -f ${tmp}`);
            fs.unlinkSync(tmp);
            console.log('Provisioning completed');
