name: Coverage Authority (PR)

on:
  workflow_run:
    workflows:
      - "CI — User-service Component Tests"
      - "CI — Order-service Component Tests"  
      - "CI — Product-service Component Tests"
      - "CI — Notification-service Component Tests"
      - "CI — Frontend Component Tests"
    types:
      - completed
    branches:
      - '**'  # Run for all branches (will filter for PR later)

jobs:
  check-completion:
    name: Check if all service tests completed
    runs-on: ubuntu-latest
    if: github.event.workflow_run.event == 'pull_request' && github.event.workflow_run.conclusion == 'success'
    outputs:
      all_completed: ${{ steps.check.outputs.all_completed }}
      user_run_id: ${{ steps.check.outputs.user_run_id }}
      order_run_id: ${{ steps.check.outputs.order_run_id }}
      product_run_id: ${{ steps.check.outputs.product_run_id }}
      notification_run_id: ${{ steps.check.outputs.notification_run_id }}
      frontend_run_id: ${{ steps.check.outputs.frontend_run_id }}
      
    steps:
      - name: Check all workflows completed
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const requiredWorkflows = [
              'CI — User-service Component Tests',
              'CI — Order-service Component Tests',
              'CI — Product-service Component Tests',
              'CI — Notification-service Component Tests',
              'CI — Frontend Component Tests'
            ];
            
            const headSha = context.payload.workflow_run.head_sha;
            const repo = context.repo;
            
            console.log(`Checking workflows for commit: ${headSha}`);
            
            // Get all workflow runs for this commit
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: repo.owner,
              repo: repo.repo,
              head_sha: headSha,
              event: 'pull_request'
            });
            
            console.log(`Found ${workflowRuns.workflow_runs.length} workflow runs for this commit`);
            
            // Filter for required workflows
            const relevantRuns = workflowRuns.workflow_runs.filter(run => 
              requiredWorkflows.includes(run.name)
            );
            
            console.log(`Relevant workflow runs: ${relevantRuns.length}`);
            
            // Group by workflow name and get latest run for each
            const latestRunsByWorkflow = {};
            for (const run of relevantRuns) {
              if (!latestRunsByWorkflow[run.name] || 
                  new Date(run.created_at) > new Date(latestRunsByWorkflow[run.name].created_at)) {
                latestRunsByWorkflow[run.name] = run;
              }
            }
            
            // Check if all required workflows have started and completed
            const startedWorkflows = Object.keys(latestRunsByWorkflow);
            console.log(`Started workflows (${startedWorkflows.length}): ${startedWorkflows.join(', ')}`);
            
            // Check completion status
            const completedWorkflows = startedWorkflows.filter(name => {
              const run = latestRunsByWorkflow[name];
              const isCompleted = ['completed', 'success', 'failure', 'cancelled', 'skipped'].includes(run.status) || run.conclusion !== null;
              console.log(`${name}: status=${run.status}, conclusion=${run.conclusion}, completed=${isCompleted}`);
              return isCompleted;
            });
            
            console.log(`Completed workflows (${completedWorkflows.length}): ${completedWorkflows.join(', ')}`);
            
            // Check if all started workflows are completed
            const allCompleted = startedWorkflows.length > 0 && 
                                startedWorkflows.length === completedWorkflows.length;
            
            console.log(`All workflows completed: ${allCompleted}`);
            
            core.setOutput('all_completed', allCompleted.toString());
            
            // Set individual run IDs for artifact download
            if (allCompleted) {
              const runIdMap = {
                'CI — User-service Component Tests': 'user_run_id',
                'CI — Order-service Component Tests': 'order_run_id',
                'CI — Product-service Component Tests': 'product_run_id',
                'CI — Notification-service Component Tests': 'notification_run_id',
                'CI — Frontend Component Tests': 'frontend_run_id'
              };
              
              for (const [workflowName, outputKey] of Object.entries(runIdMap)) {
                const run = latestRunsByWorkflow[workflowName];
                if (run) {
                  console.log(`Setting ${outputKey} = ${run.id}`);
                  core.setOutput(outputKey, run.id.toString());
                }
              }
            }
            
            if (!allCompleted) {
              console.log('⏳ Waiting for other workflows to complete...');
              console.log(`Started: ${startedWorkflows.length}, Completed: ${completedWorkflows.length}`);
            } else {
              console.log('✅ All service workflows have completed!');
            }

  aggregate:
    name: Aggregate and enforce coverage policy
    runs-on: ubuntu-latest
    needs: check-completion
    if: needs.check-completion.outputs.all_completed == 'true'

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Download user-service coverage
        uses: actions/download-artifact@v4
        with:
          name: raw-coverage-user-service
          run-id: ${{ needs.check-completion.outputs.user_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: raw-coverage/raw-coverage-user-service

      - name: Download order-service coverage
        uses: actions/download-artifact@v4
        with:
          name: raw-coverage-order-service
          run-id: ${{ needs.check-completion.outputs.order_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: raw-coverage/raw-coverage-order-service

      - name: Download product-service coverage
        uses: actions/download-artifact@v4
        with:
          name: raw-coverage-product-service
          run-id: ${{ needs.check-completion.outputs.product_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: raw-coverage/raw-coverage-product-service

      - name: Download notification-service coverage
        uses: actions/download-artifact@v4
        with:
          name: raw-coverage-notification-service
          run-id: ${{ needs.check-completion.outputs.notification_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: raw-coverage/raw-coverage-notification-service

      - name: Download frontend coverage
        uses: actions/download-artifact@v4
        with:
          name: raw-coverage-frontend
          run-id: ${{ needs.check-completion.outputs.frontend_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: raw-coverage/raw-coverage-frontend

      # ---- Normalize each service ----

      - name: Normalize all services
        run: |
          set -e
          declare -A services=( \
            ["frontend"]="jest:raw-coverage/raw-coverage-frontend/coverage-summary.json" \
            ["notification-service"]="pytest:raw-coverage/raw-coverage-notification-service/coverage.json" \
            ["order-service"]="jacoco:raw-coverage/raw-coverage-order-service/jacoco.xml" \
            ["product-service"]="jest:raw-coverage/raw-coverage-product-service/coverage-summary.json" \
            ["user-service"]="jacoco:raw-coverage/raw-coverage-user-service/jacoco.xml" \
          )
          for svc in "${!services[@]}"; do
            IFS=':' read -r fmt path <<< "${services[$svc]}"
            mkdir -p coverage/$svc
            bash scripts/normalize.sh "$fmt" "$svc" "$path" "coverage/$svc"
          done

      - name: Validate normalized JSON
        run: |
          set -euo pipefail
          for f in coverage/*/coverage.json; do
            jq -e '
              has("service") and
              has("language") and
              has("lines") and
              (.lines | has("total") and has("covered") and has("missed") and has("coverage_pct"))
            ' "$f" || { echo "❌ $f failed validation"; exit 1; }
            echo "✓ $f passed validation"
          done

      - name: Aggregate coverage
        run: |
          set -euo pipefail

          jq -s '
            def sum(field): map(.lines[field]) | add;

            {
              services: .,
              overall: {
                total:   sum("total"),
                covered: sum("covered"),
                missed:  sum("missed"),
                coverage_pct:
                  if sum("total") > 0
                  then ((sum("covered") / sum("total")) * 100 | round )
                else 0
                end
              }
            }
          ' coverage/*/coverage.json > coverage/aggregate.json

      - name: Validate aggregate schema
        run: |
          set -euo pipefail

          jq -e '
            .overall.total >= 0 and
            .overall.covered >= 0 and
            .overall.missed >= 0 and
            .overall.covered + .overall.missed == .overall.total and
            (.overall.coverage_pct | type == "number")
          ' coverage/aggregate.json > /dev/null

          echo "✓ Aggregate coverage passed validation"

      - name: Enforce policy
        run: |
          set -euo pipefail
          
          MIN=$(jq -r '.minCoverage' coverage/contract.json)
          ACTUAL=$(jq -r '.overall.coverage_pct' coverage/aggregate.json)

          echo "Coverage: $ACTUAL%, Minimum: $MIN%"

          if [ "$ACTUAL" -lt "$MIN" ]; then
            echo "❌ Coverage policy violation"
            exit 1
          fi

      - name: Generate badge
        run: |
          set -euo pipefail
          
          jq '
            .overall.coverage_pct as $c |
            {
              schemaVersion: 1,
              label: "coverage",
              message: (($c | tostring) + "%"),
              color:
                if $c >= 80 then "brightgreen"
                elif $c >= 65 then "yellow"
                else "red"
                end
            }
          ' coverage/aggregate.json > coverage/badge.json

      - name: Publish badge
        uses: peaceiris/actions-gh-pages@v4
        with:
          publish_branch: coverage-badge
          publish_dir: coverage
        continue-on-error: false