**Developer Workflows — Sparse checkout, local testing, and CI structure**

This file explains lightweight local workflows (sparse-checkout), how to run a single service locally, and how CI is organized for the monorepo.

1) Sparse-checkout (work on a single service)
------------------------------------------------
If you don't need the whole repository locally, use Git's sparse checkout to fetch only a service directory.

Clone only metadata first, then choose the service path you need:

```bash
# clone with sparse support (no large blobs)
git clone --filter=blob:none --sparse git@github.com:kunlecreates/shop-ease-enterprise-app.git
cd shop-ease-enterprise-app

# pick the service you need (example: order-service)
git sparse-checkout set services/order-service

# check out the branch you work on
git checkout main
```

To add more folders later:

```bash
git sparse-checkout add services/product-service services/user-service
```

2) Running a single service locally
------------------------------------
General guidance — each service contains its own build/test tooling. Examples below assume you are in the repo root.

- Java (Maven) services (user-service, order-service):

```bash
# build shared test-utils (if running integration tests that use it)
mvn -B -f services/test-utils/pom.xml install

# run tests for order-service (Testcontainers requires Docker)
DOCKER_HOST=tcp://127.0.0.1:2375 mvn -Dapi.version=1.44 -f services/order-service test
```

If your Docker daemon uses the default unix socket you do NOT need `DOCKER_HOST` or `-Dapi.version` — those were used in some environments to negotiate the Docker API version.

- Node.js service (product-service):

```bash
cd services/product-service
npm ci
npm test
```

- Python service (notification-service):

```bash
cd services/notification-service
python -m pip install -r requirements.txt
pytest
```

3) Testcontainers and shared test migrations
-------------------------------------------
- Shared, test-only Flyway migrations and a small `TestContainersConfig` module live in `services/test-utils`.
- When running integration tests locally for Java services, first install `test-utils`:

```bash
mvn -B -f services/test-utils/pom.xml install
```

- Testcontainers requires Docker; ensure Docker is running and accessible. If Testcontainers cannot find the daemon, configure your environment accordingly.

4) CI Structure (what runs where)
---------------------------------
- Per-service workflows: There are dedicated workflows for each service under `.github/workflows/ci-<service>.yml`. These workflows are configured with `paths` filters so they only trigger when files under `services/<service>/` change.
  - `.github/workflows/ci-order-service.yml`
  - `.github/workflows/ci-user-service.yml`
  - `.github/workflows/ci-product-service.yml`
  - `.github/workflows/ci-notification-service.yml`

- Global workflows (CI, Integration Tests):
  - `.github/workflows/ci.yml` and `.github/workflows/integration-tests.yml` still exist for infra-level checks and cross-service flows, but they are configured with `paths-ignore: 'services/**'` so they won't duplicate per-service runs for common service changes.

- Integration tests workflow (`integration-tests.yml`) contains a `prepare` job that builds and installs `services/test-utils` into the local Maven cache so the matrixed integration jobs can reuse the shared migrations.

5) Pull Requests and checks
---------------------------
- When you open a PR that modifies only files under `services/<service>/`, the corresponding per-service workflow will run and show status checks on the PR.
- When a PR touches infra, workflows, or cross-service code (for example `services/test-utils`, `.github/**`, `helm/`, `docs/`) the global CI and integration workflows may run.

6) Ownership and reviews
-------------------------
- There is a `CODEOWNERS` file under `.github/CODEOWNERS` that assigns default reviewers per-service. The owners will be requested automatically for PR reviews.

7) Notes and troubleshooting
---------------------------
- If CI fails due to missing secrets or environment variables, open the failing job and check the logs — many per-service workflows are intentionally minimal and may require additional secrets (for example, external API keys) to run integration tests.
- If Testcontainers cannot start containers in CI, verify the runner has Docker available and that any required permissions (self-hosted runners) are configured.

If you'd like, I can also add a short `scripts/` helper to run a single-service test locally (wrapping the mvn/npm/pytest commands) — tell me if you want that and which services to include.

--
Generated by repo tooling to speed local development and make CI behavior predictable.
